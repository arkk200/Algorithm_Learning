- 삽입 정렬 -


『 각 숫자를 적절한 위치에 삽입한다. 』

삽입 정렬은 O(N^2)을 가지는 세 알고리즘 중 가장 빠르다.





- 과정 -

삽입 정렬은 앞에 있는 요소들이 이미 정렬이 되어 있다고
가정을 한다.
이 점에서 버블, 선택 정렬보다 좀 더 효율적이다.

1 10 5 8 7 6 4 3 2 9

여기서 두번째에 10이 앞에 있는 요소들 중 들어갈 위치는
_ 1 _ 10이다.

10은 1보다 크니 그대로 위치를 유지한다.
=> 1 10 5 8 7 6 4 3 2 9

세번째에 5도 마찬가지로 앞에 있는 요소들 중 들어갈 위치는
_ 1 _ 10 _ 5 이다.

5는 10보다 작고 1보다 크므로 1과 10 사이에 들어간다.
=> 1 5 10 8 7 6 4 3 2 9

네번째에 8도 앞에서 했던 것처럼 하면
10보다 작고 5보다 크므로 그 사이에 들어간다.
=> 1 5 8 10 7 6 4 3 2 9

다섯번째에 7은 8보다 작고 5보다 크므로
=> 1 5 7 8 10 6 4 3 2 9

계속 반복하면
=> 1 5 6 7 8 10 4 3 2 9

=> 1 4 5 6 7 8 10 3 2 9

=> 1 3 4 5 6 7 8 10 2 9

=> 1 2 3 4 5 6 7 8 10 9

=> 1 2 3 4 5 6 7 8 9 10

결국 정렬이 일어난다.

삽입정렬은 현재 값부터 한 칸씩 앞에 있는 값과 비교해서
만약 크다면 한 칸씩 오른쪽으로 움직이고
작다면 바로 삽입만 해주면 된다.

앞에 값은 이미 정렬이 된 상태이기 때문에
값이 있어야할 위치만큼만 움직이고 삽입만 해주면 된다.
따라서 연산이 선택, 버블 정렬보다 더 적게 이루어진다.





- 시간복잡도 -

『 삽입 정렬의 시간 복잡도는 O(N^2)입니다. 』

하지만 삽입 정렬 또한 최악의 경우엔 O(N^2)의 시간 복잡도를 가진다.

그러나 실제로는 연산 횟수가 가장 적게 일어난다는 점에서 
O(N^2)중엔 가장 뛰어나다고 할 수 있다.

만약
2, 3, 4, 5, 6, 7, 8, 9, 10, 1 같이
거의 정렬된 상태에선 어떤 알고리즘보다도 빠르다는 특징이 있다.