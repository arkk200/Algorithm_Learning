- 퀵 정렬 -

이 때까지의 정렬 알고리즘은 O(N^2)의 시간 복잡돌르 같는 
정렬 알고리즘이었다.
(데이터 개수가 10만개만 넘어가도 사용하기 매우 어렵다.)
(O(N^2)에서 N이 10만이면 수행시간은 100억이다 ㄷㄷ)

이를 보안하기 위해 나온 대표적인 빠른 알고리즘이 
퀵정렬이다.

퀵정렬은 대표적인 '분할 정복' 알고리즘으로
평균 수행 속도가 O(N * log N)이다.
(N이 10만이라도 166만밖에 안나온다.)

퀵 정렬은 처음 접했을 때 어렵게 느껴질 수 있다.
그러나 한 번 작성해보면 매우 쉬운 알고리즘이다.

『 특정한 값을 기준으로 큰 숫자와 작은 숫자를 나눈다. 』
(원소를 두 집합으로 나눈다.)

퀵 정렬에는 피벗(Pivot)이라는 기준값이 있다.
이 피벗 값을 기준을 왼쪽과 오른쪽을 나눈다.





- 과정 -

3 7 8 1 5 9 6 10 2 4

---- 1. 피벗 값 설정하기 ----
퀵 정렬에 피벗 값을 설정을 할 때 가장 앞에 있는 숫자를 
피벗 값으로 설정을 할 때가 많다.

(3) 7 8 1 5 9 6 10 2 4

남은 값들 중 각각 맨 왼쪽에서 오른쪽으로, 맨 오른쪽에서 왼쪽으로 
검사를 시작한다. (여기서 맨 왼쪽 값은 7, 맨 오른쪽 값은 4)

---- 2. 값 선택하기 ----
맨 왼쪽에서 오른쪽으로 이동하면서 검사할 땐 
피벗 값보다 큰 값을 선택한다.

(맨 왼쪽에서 시작하는데 맨 왼쪽 값 7이 피벗 값 3보다 크므로 선택됨)

=> (3) 7 8 1 5 9 6 10 2 4
       ^

반대로 맨 오른쪽에서 왼쪽으로 이동하면서 검사할 땐 
피벗 값보다 작은 값을 선택한다.

(맨 오른쪽에서 시작하고 왼쪽으로 차례대로 검사를 시작하면 
가장 먼저 나온 피벗 값 3보다 작은 2가 선택됨)
=> (3) 7 8 1 5 9 6 10 2 4
       ^              ^

---- 3. 선택된 값 위치 서로 바꾸기 ----
선택된 두 값의 위치를 바꾼다. (7과 2가 선택됐으므로 서로 위치를 바꿈)
=> (3) 2 8 1 5 9 6 10 7 4
       <              >
바껴도 피벗 값은 바뀌지 않는다.

마찬가지로 다시 2. 값 선택하기 단계와 같은 
검사를 통해 큰 값과 작은 값을 찾고 
=> (3) 2 8 1 5 9 6 10 7 4 (큰 값: 8, 작은 값: 1)
         ^ ^

3. 선택된 값 위치 서로 바꾸기 단계를 실행한다.
=> (3) 2 1 8 5 9 6 10 7 4
         < >

---- 4. 값이 엇갈린다면 ----
위에 2, 3단계 사이클을 계속하다가 2단계에서 
2단계와 같은 검사를 통해 찾은 큰 값의 위치와 
작은 값의 위치가 서로 엇갈린다면, 

즉, 작은 값의 인덱스가 큰 값의 인데스보다 작다면 
=> (3) 2 1 8 5 9 6 10 7 4
         ^ ^
(맨 왼쪽부터 피벗 값보다 가장 큰 값 : 8
맨 오른쪽부터 피벗 값보다 가장 작은 값 : 1
작은 값의 인덱스가 큰 값의 인데스보다 작음)

왼쪽에 있는 값인 작은 값과, 피벗 값의 위치를 바꿔준다.
=> 1 2 3 8 5 9 6 10 7 4
   <   >
이 때 3은 정렬을 이루게 된다.

그리고 3을 기준으로 했을 때,
왼쪽에 있는 값은 3보다 작고,
오른쪽에 있는 값은 3보다 크다는 특징을 가진다.

이렇게 나눠진 왼쪽 집합과 오른쪽 집합을 
위에 1부터 4단계로 피벗을 정렬하고 집합을 나누는 것을 반복한다.
(1 2 | 3 | 8 5 9 6 10 7 4)

피벗 값 3이 정렬된 집합의 왼쪽 집합을 보면
1이 피벗이 된고
(1) 2
오른쪽 집합은 8이 피벗이 된다.
(8) 5 9 6 10 7 4

1이 피벗인 집합을 보면
2. 값 선택하기 단계에서
제일 작은 값이 안나오는데 이 때 가장 작은 값으로 자기자신을 선택한다.
=> (1) 2
    ^  ^
큰 값을 선택한 인덱스와 작은 값을 선택한 인덱스가 서로 엇갈렸으므로 
선택된 가장 작은 값과 피벗의 위치를 바꾼다.

(선택된 가장 작은 값과 피벗의 값이 동일하므로 그대로)
=> 1 2
이 때 1도 마찬가지로 정렬을 이루게 된다.

또 1을 기준으로 왼쪽 집합과 오른쪽 집합을 나눈다.
| 1 | 2
여기서 왼쪽 집합은 존재하지 않으므로 오른쪽 집합을 봤을 때 
값이 2 하나이므로 그대로 나둔다.
이 때 2도 정렬을 이루게 된다.

결과적으로 전체 집합은
=> 1 2 3 8 5 9 6 10 7 4 가 되고 1, 2, 3은 정렬이 된 상태이다.

계산을 안했었던 8이 피벗인 오른쪽 집합을 보면 

(8) 5 9 6 10 7 4에서
피벗보다 큰 값인 9가 선택되고 피벗보다 작은 값인 4가 선택된다.
=> (8) 5 9 6 10 7 4
         ^        ^

두 값의 위치를 바꾼다.
=> (8) 5 4 6 10 7 9
         <        >

똑같이 피벗보다 큰 값과 작은 값을 선택 후 서로 위치를 바꾼다.
=> (8) 5 4 6 10 7 9
              ^ ^

=> (8) 5 4 6 7 10 9
             <  >

두 인덱스가 엇갈렸으므로 피벗과 가장 작은 값을 바꾸고 
=> 7 5 4 6 8 10 9
   <       >
피벗을 기준으로 왼쪽과 오른쪽 집합은 나눈다.
7 5 4 6 | 8 | 10 9

여기서 8 또한 정렬을 이루게 된다.

7이 피벗이 된 왼쪽 집합을 먼저 살펴보면
(7) 5 4 6에서 7보다 큰 값은 없으므로 
큰 값을 선택하는 인덱스는 6다음의 값을 선택하게 되고
가장 작은 값은 6을 선택하게 된다.
=> (7) 5 4 6
           ^ ^

두 인덱스가 엇갈렸으므로 가장 작은 값과 피벗을 바꿔준다.
=> 6 5 4 7
   <     >

7도 정렬을 이루게 된다.
피벗 7을 기준으로 집합을 두 개로 또 나눠보면
6 5 4 | 7 | 로 왼쪽 집합의 피벗은 6이다.

반복을 해보면
=> (6) 5 4
         ^ ^ (엇갈림)
=> 4 5 6
   <   >
6은 정렬을 이룸
4 5 | 6 |

(4) 5
    ^ (작은 값 없음 => 자기자신 선택)
=> 4 5
   ^ ^ (엇갈림)

=> 4 5
4는 정렬을 이룸

| 4 | 5
5는 하나이므로 정렬을 이룸
전체 집합을 정리하자면 
1 2 3 4 5 6 7 8 | 10 9

남은 오른쪽 집합을 보면 
=> (10) 9
        ^ ^ (엇갈림)
=> 9 10
   <  >
10은 정렬을 이룸
9 | 10 |
9는 하나이므로 정렬을 이룸

정렬할 남은 집합이 없으므로 끝이 남





- 시간복잡도 -

『 퀵 정렬의 시간 복잡도는 O(N * log N)입니다. 』

이런 속도 나온 까닭은 만약 N이 10일 때

N ^ 2 같은 경우, 
(1 2 3 4 5 6 7 8 9 10)
=> 10 * 10 = 100인데

반으로 5개 씩 분할하여 각각 정렬하는 경우,
(1 2 3 4 5) => 5 * 5 => 25
(6 7 8 9 10) => 5 * 5 => 25
=> 50밖에 안 걸린다.

하지만 최악의 경우엔 퀵 정렬도 O(N^2)의 시간 복잡도를 가진다.

『 퀵 정렬의 최악 시간 복잡도는 O(N^2)입니다. 』

즉, 항상 N * log N을 보장할 순 없다.

만약 숫자가 이미 오름차순 또는 내림차순으로 정렬되어 있는 경우
분할하여 집합을 나누지 못하기 때문에 O(N^2)의 시간 복잡도를 가지게 된다.