* 알고리즘은 소스코드를 바로 실행하는 것보다 손으로 먼저 써보는게 중요하다.





- 선택 정렬 -

선택정렬은 아래에 문장만 기억해도 됨

『 가장 작은 것을 선택해서 제일 앞으로 보낸다. 』





- 과정 -

1 10 5 8 7 6 4 3 2 9

1번째부터 10개 중 1이 가장 작음 => 1번째 값과 위치를 바꿈 (그대로임)
=> 1 10 5 8 7 6 4 3 2 9

2번째부터 남은 9개 중 2가 가장 작음 => 2번째 값과 위치를 바꿈
=> 1 2 5 8 7 6 4 3 10 9

3번째부터 남은 8개 중 3이 가장 작음 => 3번째 값과 위치를 바꿈
=> 1 2 3 8 7 6 4 5 10 9

4번째부터 남은 7개 중 4가 가장 작음 => 4번째 값과 위치를 바꿈
=> 1 2 3 4 7 6 8 5 10 9

5번째부터 남은 6개 중 5가 가장 작음 => 5번째 값과 위치를 바꿈
=> 1 2 3 4 5 6 8 7 10 9

6번째부터 남은 5개 중 6이 가장 작음 => 6번째 값과 위치를 바꿈 (그대로임)
=> 1 2 3 4 5 6 8 7 10 9

7번째부터 남은 4개 중 7이 가장 작음 => 7번째 값과 위치를 바꿈
=> 1 2 3 4 5 6 7 8 10 9

8번째부터 남은 3개 중 8이 가장 작음 => 8번째 값과 위치를 바꿈 (그대로임)
=> 1 2 3 4 5 6 7 8 10 9

9번째부터 남은 2개 중 9가 가장 작음 => 2번째 값과 위치를 바꿈
=> 1 2 3 4 5 6 7 8 9 10

마지막 숫자 10은 남은 숫자가 1개로 자기자신이므로 바꿔도 그대로임





- 시간복잡도 - (선택 정렬의 한계)

『 선택 정렬의 시간 복잡도는 O(N^2)입니다. 』

N이 10일 때 반복 횟수
10번 + 9번 + 8번 + ... + 1번

=> 10 * (10 + 1) / 2 = 255

=> N * (N + 1) / 2

(일반적으로 컴퓨터에서 간단하게 나누거나 더한 값은
N이 굉장히 크다는 가정 하에 별 의미가 없기에
간단하게 나누거나 더하는 연산은 무시를 한다.)
=> N * N

(대략적인 수행 시간 표기할 때 Big-O 표기법을 사용한다.)
=> O(N*N)

특정한 알고리즘의 수행시간을 
가장 간략하게 표기한게 빅오 표기법이다.

(빅오 표기법은 다양한 표기법 중 하나이다.
일반적인 알고리즘에선 빅오 표기법을 표기법으로 사용한다.)

정렬 알고리즘에서 O(N^2)의 시간 복잡도는 비효율적인 알고리즘이다.
10000개를 정렬할 때 1억번의 수행시간이 걸린다...
(이차원 배열처럼 값이 조금만 커져도 수행시간이 제곱만큼 커진다.)

따라서 처리할 개수가 많을 땐 피해야 할 시간 복잡도 중 하나이다.