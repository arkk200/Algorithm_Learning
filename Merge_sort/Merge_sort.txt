- 병합 정렬 -

병합 정렬은 퀵 정렬과 다르게 편향되게 나누지 않고 
정확히 반절씩 나눈다는 점에서 최악의 경우에도 
O(N log N)을 보장한다.

『 일단 반으로 나누고 나중에 합쳐서 정렬한다. 』





- 과정 -

병합 정렬은 퀵 정렬과 다르게 피벗 값이 없다.
그 이유는 항상 반으로 나누기 때문이다. 
따라서 항상 O(N log N)을 보장한다.

7 | 6 | 5 | 8 | 3 | 5 | 9 | 1

정렬할 배열은 전부 요소가 한 개씩 남을 때까지 
계속 반으로 나눠서 
하나씩 쪼개져있는 상태라고 생각한다.

쪼개진 배열을 합칠때는 2의 배수만큼 합친다.

첫번째로 합칠 땐 2개씩 합친다.
=> 7 6 | 5 8 | 3 5 | 9 1

합친 뒤 만들어진 집합은 정렬을 수행한다.
=> 6 7 | 5 8 | 3 5 | 1 9
   < >               < >
(*사실은 합치는 순간에 정렬을 수행한다.)

두번째로 합칠 땐 4개씩 합친다.
=> 6 7 5 8 | 3 5 1 9

이때 만들어진 집합 또한 정렬을 수행한다.
=> 5 6 7 8 | 1 3 5 9
   < > >     < > >

마지막으로 8개씩 합치고 
=> 5 6 7 8 1 3 5 9

정렬을 하면
=> 1 3 5 5 6 7 8 9
   < < < > > > >

정렬이 끝난다.

* 중요한건 합치는 순간에 정렬을 수행한다는 것이다.
예를 들어


6 7 | 5 8
^     ^
i     j
_ _ _ _
^
k

처럼 두 집합이 있고 각각 첫번째 값을 i, j가 가르킬 때,

i, j 중 가장 작은 값을 더 큰 집합의 앞쪽에 넣고

- 1 -
6 7 | 5 8
^     ->^
i       j
5 _ _ _
  ^
  k

인덱스를 한 칸 올린다.

똑같이 반복하면

- 2 -
6 7 | 5 8
->^   ->^
  i     j
5 6 _ _
    ^
    k

- 3 -
6 7 | 5 8
  ^   ->^
  i     j
5 6 7 _
      ^
      k

- 4 -
6 7 | 5 8
  ^     ^
  i     j
5 6 7 8


가 되고 정렬을 이룬다.
이 때 수행 횟수가 너비와 같으므로 N,
이를 log N만큼 수행하므로 
O(N log N)의 수행 시간을 갖는다.

퀵정렬보단 평균적으로 빠르진 않지만
O(N log N)을 보장한다는 큰 장점이 있다.





- 시간복잡도 -

『 병합 정렬의 시간 복잡도는 O(N * log N)입니다. 』

병합 정렬은 정렬에 사용되는 배열은 전역 변수롤 선언하고, 
'기존의 데이터를 담을 추가적인 배열 공간이 필요하다.'
=> (메모리 활용이 비효율 적임)