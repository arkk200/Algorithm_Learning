- 힙 정렬 -

『 힙을 이용해 데이터를 정렬한다. 』

힙 정렬은 '힙 트리 구조(Heap Tree Structure)'를 이용하는 
정렬 방법이다.
힙을 알기 위해선 이진 트리(Binary Tree)를 알아야한다.

이진 트리란?
컴퓨터가 데이터를 표현하고자 할 때 데이터를 두 개씩 이어붙인 구조를 말한다. 
이때 이 데이터는 노드라고도 한다.

쉽게 말해 모든 노드의 자식 노드가 2개 이하인 트리 구조를 이진 트리라고 한다.

트리의 최상단에 있는 노드를 루트 노드. 
트리의 최하단에 있는 노드를 리프 노드라고 한다.


이진 트리 중 데이터가 들어올 때 
왼쪽 노드부터 차례대로 들어오는 트리 구조를 
완전 이진 트리라고 한다.


힙은 최솟값 또는 최댓값을 아주 빠르게 찾아내기 위해서 
완전 이진 트리를 이용하는 하나의 트리 구조 이다.

힙에는 최대 힙과 최소 힙이 존재하는데 
최대 힙은 부모 노드가 자식 노드보다 큰 힙이다.

힙 정렬을 하기 위해서는 기본적으로 힙 구조를 가지도록 만들어야 한다.

만약 
      11
   !5     8
  !7 4
와 같이 부모(5)가 자식(7)보다 작아 최대 힙이 형성되지 않은 요소가 
발생했다면 자식 중 더 큰 값과 부모를 바꿔준다.

이런 알고리즘을 힙 생성 알고리즘(Heapify Algorithm)이라고 한다.
힙 생성 알고리즘은 단 하나의 노드에 대해서 수행한다.

이 힙 생성 알고리즘을 수행한다면 최대 힙 구조를 만들 수 있다.

위에서 자식과 부모를 바꾸더라도 그 자식이 자신의 자식보다 작은 경우 
큰 자식과 또 서로의 위치를 바꿔준다.

힙 생성 알고리즘의 시간 복잡도는 높이인 log N에
모든 정점인 N을 곱해서 N log N이 걸리고 이러한 수행 시간만으로 
힙 구조를 만들어낼 수 있다.

근데 실제로는 (1/2) * N log N의 시간만으로도 힙구조를 만들어낼 수 있다.
하지만 (1/2) * N이 log N보다 더 크다는 점에서 그냥 N으로 바꿀 수가 있다.

즉, 전체 트리를 힙으로 만드는 시간은 (1/2) * N log N가 걸리고 
결과적으로 시간 복잡도는 O(N)이 된다.





- 과정 -

기본적으로 완전 이진 트리는 배열에 그대로 삽입해도 문제가 없다.

7 6 5 8 3 5 9 1 6이라는 배열이 있고 

아래처럼 완전 이진 트리순으로 삽입된다는 의미이다.
          7
     6         5
  8     3   5     9
1   6

즉
노드: 0 1 2 3 4 5 6 7 8
배열: 7 6 5 8 3 5 9 1 6
순으로 들어간다.

힙 구조를 만드는데 O(N)이 걸린다고 했으므로 9번만큼 연산을 해주면 
힙 구조가 만들어진다.

          7
     6         5
  8     3   5     9
1   6
여기선 실제론 8, 6, 5, 7이 위치해있는 노드만 보면 된다.
따라서 살펴봐야할 요소는 전체요소 / 2의 내림수이다. (요소가 9개니 4개만 봄)

먼저 8을 보면 8은 8의 자식인 1과 6보다 크다. 따라서 무시한다.
          7
     6         5
  8     3   5     9
1   6

그리고 5를 보면 5는 5의 자식 중 9보다 작으므로 9와 위치를 바꿔준다.
          7
     6         9
  8     3   5  <  5
1   6             >

7을 보면 7은 7의 자식 중 9보다 작으므로 9와 위치를 바꿔준다.

          9
     6    <    7
  8     3   5  >  5
1   6

6을보면 6은 6의 자식 중 8보다 작으므로 8과 위치를 바꿔준다.

          9
     8         7
  6  >  3   5     5
1 < 6

9의 자식 중 6보다 큰 값은 없으므로 무시한다.

          9
     8         7
  6     3   5     5
1   6

힙 구조가 만들어졌다.
위는 상향식으로 힙 구조를 만든 것이다.
하향식으로도 만들 수 있다.

나오는 힙 구조가 다양해도 힙 구조이기만 하면 
정렬을 할 수 있다.

힙구조가 만들어졌다면 반복적으로 특정한 작업을 수행해야한다.

1. 만들어진 힙 구조의 최상단은 무조건 현재 집합 중 
가장 큰 값이 들어가기 때문에 가장 마지막 원소와 바꿔준다.

2. 만들어진 힙 구조 중 마지막 원소에 들어간 큰 값을 제외하고 
다시 힙 생성 알고리즘을 수행한다.

이 두가지 단계를 반복한다.

-- 1회전 --
1. 위치 바꿈
          6
     8    >    7
  6     3   5     5
1   9
    <

2. 마지막 요소 제외 후 힙 구조 생성
_ _ _ _ _ _ _ _ 9
          8
     6         7
  6     3   5     5
1

-- 2회전 --
1.
          1
     6    >    7
  6     3   5     5
8
<

2.
_ _ _ _ _ _ _ 8 9
          7
     6         5
  6     3   1     5

-- 3회전 --
1.
        5
   6    <    5
6     3   1     7
                >

2.
_ _ _ _ _ _ 7 8 9
        6
   6         5
5     3   1

-- 4회전 --
1.
        1
   6    <    5
5     3   6
          >

2.
_ _ _ _ _ 6 7 8 9
        6
   5         5
1     3

-- 5회전 --
1.
        3
   5    >    5
1     6
      <

2.
_ _ _ _ 6 6 7 8 9
        5
   3         5
1

-- 6회전 --
1.
        1
   3    >    5
5
<

2.
_ _ _ 5 6 6 7 8 9
        5
   3         1

-- 7회전 --
1.
     1
3    <    5
          >

2.
_ _ 5 5 6 6 7 8 9
     3
1

-- 8회전 --
1.
     1
3    >
<

2.
_ 3 5 5 6 6 7 8 9
     1

-- 9회전 --
1.
     1
     ^

2.
1 3 5 5 6 6 7 8 9

정렬이 끝난다.
힙을 만드는 알고리즘의 시간 복잡도는 log N, 
원소가 총 N개 이므로 
최종적으로 N * log N의 시간이 걸린다.





- 시간복잡도 -

『 힙 정렬의 전체 시간 복잡도는 O(N * log N)입니다. 』

힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 
메모리 측면에서 몹시 효율적인 알고리즘이다.
또한 항상 O(N log N)을 보장할 수 있다는 점에서 매우 강력한 정렬 알고리즘이다. 

그래서 이론적으로 보면 퀵 정렬, 병합 정렬보다 더 우위에 있다고 할 수 있다.